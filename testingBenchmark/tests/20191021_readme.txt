function_para.js: to test that a function can be a parameter to be passed to another function.

a.js,b.js,and cycling_require.js: to test cycling require() between different modules. That is, a.js requires b.js while b.js requires a.js. and  main.js requires both a.js and b.js. This test case also test the cache property of require(). The execution results of main.js can show the cycling require() process.

return_constructor_function.js, return_objects.js, return_instance.js, test_exports.js, and module_prototype_test.js: to test module.exports, exports and prototype grammar.  
return_constructor_function.js uses module.exports and return a constructor function. 
return_object.js uses module.exports and returns a JSON object.
return_instance.js uses module.exports and returns a instance object.
test_exports.js uses exports  to expose two functions.
(module_prototype_test.js requires all the four js modules.) 

array_loop.js: test for loop, forEach, for in, for of grammar. It also exports two array fruits[] and person[].

require_array_loop.js: it requires arrary_loop.js and test for loop.

name_inheritance.js: a simple test includes prototype inheritance, properties inheritance, and function inheritance.

merge_vul.js:  a simple example of prototype pollution. the merge function here has a potential prototype pollution vulnerability.
test_merge_clone.js, merge_function.js, clone_function.js: test_merge_clone.js requires merge_function.js and clone_function.js. 
clone_function.js requires merge_functions.js to construct Function clone ().
merge_function here has fixed the prototype pollution vulnerability in merge_vul.js. So the outputs in test_merge_clone.js and merge_vul.js are different.





 